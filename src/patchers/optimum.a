;-------------------------------
; #Optimum
; self-overwriter that restores
; content later from custom sector
; e.g. StickyBear Math
;
; module by qkumba
;-------------------------------
!zone {
         lda   gIsOptimum
         bne   .jmpexit
         ldx   gTrack
         beq   .jmptrack0
         dex
         beq   .dotrack1
         ldy   #15
         jsr   SearchTrack
         !byte $A2,$00      ;LDX #$00
         !byte $A0,$00      ;LDY #$00
         !byte $BD,WILDCARD,WILDCARD ;LDA $xxxx,X
         !byte $E8          ;INX
         !byte $85,WILDCARD ;STA $xx
         !byte $BD,WILDCARD,WILDCARD ;LDA $xxxx,X
         !byte $E8          ;INX
         !byte $85          ;STA $xx
         bcs   .jmpexit
         tay
         adc   #BASEPAGE-1
         pha
         tya
         ldy   #$01
         jsr   modify
         !byte $60          ;RTS
         pla

         ;find reference to T01 S0F

         ldy   #6
         jsr   SearchSector
         !byte $01,$60,$01,$00,$01,$0F
         bcs   .jmpexit
         adc   #BASEPAGE
         sta   .iob+2

         ;save for later...

.iob
         lda   $D109,X
         sta   .address+1

.jmpexit
         jmp   .exit

.jmptrack0
         jmp   .dotrack0

.retrycount
         !byte $D1

.badread
         lda   #s_optbad  ; say read failure
         jsr   PrintByID
         jmp   .exit

.dotrack1
         lda   #3
         sta   .retrycount

.retry
         dec   .retrycount
         beq   .badread

         ;disable decoding, requires custom handling

+        lda   #$4C
         sta   $B8F6
         lda   #<.readcallback
         sta   $B8F7
         lda   #>.readcallback
         sta   $B8F8
         lda   #$2C
         sta   $BE40

         ;read T01S0F, remains encoded at $BB00-BC55

         ldy   #<gRWTSParams
         lda   #>gRWTSParams
         jsr   $BD00

         ;re-enable decoding

         lda   #$BD
         sta   $B8F6
         lda   #$8C
         sta   $B8F7
         lda   #$C0
         sta   $B8F8
         lda   #$20
         sta   $BE40

         ;detect read failure

         bcs   .retry

         ;detect write-protect
         ;work around OE issue

         ldx   gRWTSParams+1
         lda   $C08D,x
         lda   $C08E,x
         bpl   +
         ldx   $BB00
         ldy   #1
-        lda   $BB00,y
         sta   $BAFF,y
         iny
         bne   -
         ldy   #$54
-        lda   $BC00,y
         sta   $BC01,y
         dey
         bpl   -
         stx   $BC00
+
         ;decode and stash content

         lda   #$BC
         sta   .tblsel1+2
         sta   .tblsel2+2
         lda   #$88
         sta   .direction1
         sta   .direction2
         lda   #$86
         sta   $26
         ldy   #$53
-
.tblsel1
         ldx   $D100,y
         lda   (.xlattbl-$96)-$17,x
         asl
         asl
         asl
         asl
.direction1
         dey
.tblsel2
         ldx   $D100,y
.swapbase4
         ora   (.xlattbl-$96)-$17,x
         sty   $2C
         ldy   $26
         sta   $300,y
         ldy   $2C
         bne   +
         dec   .tblsel1+2
         dec   .tblsel2+2
         lda   #$C8
         sta   .direction1
         sta   .direction2
         !byte $24 ;mask DEY
+
.direction2
         dey
         dec   $26
         ldx   $26
         inx
         bne   -
         jmp   .exit

.readnib
-        lda   $C08C,x
         bpl   -
         rts

.readcallback
-        jsr   .readnib
         sta   $C08D,x
         nop
         nop
-        jsr   .readnib
         dey
         sta   $BC00,y
         bne   -
-        jsr   .readnib
         sta   $BB00,y
         iny
         bne   -
         clc
         rts

.xlattbl
         !byte $01, $00, $07, $08, $09, $01, $02, $02
         !byte $00, $01, $06, $04, $03, $04, $03, $05
         !byte $05, $00, $02, $01, $0A, $07, $0E, $05
         !byte $02, $01, $06, $07, $03, $00, $02, $05
         !byte $0B, $04, $0F, $00, $07, $0A, $01, $02
         !byte $03, $00, $0C, $0C, $06, $07, $05, $08
         !byte $06, $02, $04, $01, $00, $08, $0A, $03
         !byte $0E, $00, $01, $07, $09, $0A, $05, $0B
         !byte $02, $05, $10, $03, $04, $0C, $06, $0D
         !byte $01, $0F, $06, $05, $0E, $0F, $0B, $11
         !byte $02, $00, $09

         ;track 0, find the region with replaced page

.dotrack0
         lda   #s_construct
         jsr   PrintByID
         ldy   #8
         jsr   SearchTrack
         !byte $20,$5D,$B6  ;JSR $B65D
         !byte $01,$0E      ;track 1, sector #$0E
         !byte $00,$08,$18  ;address, count
         bcs   .exit ;give up
         adc   #BASEPAGE
         sta   .patch1+2
         sta   .patch2+2

         ;convert address to track/sector

.address
         lda   #$D1
         sbc   #7
         pha
         and   #$0F
         sta   tmp
.patch1
         lda   $D104,x
         sbc   tmp
         and   #$0F
         sta   gSector
         pla
         php
         lsr
         lsr
         lsr
         lsr
         clc
.patch2
         adc   $D103,x
         tay
         plp
         bcs   +
         iny
+        sty   gTrack

         ;read replaced page

         lda   #9         ; $900-9FF
         sta   gAddress+1
         ldy   #<gRWTSParams
         lda   #>gRWTSParams
         jsr   $BD00

         ;merge content

         ldy   #$86
-        lda   $300,y
         sta   $900,y
         dey
         cpy   #$FF
         bne   -

         ;read other page in block

         lda   #1
         sta   gTrack
         sta   gSector
         dec   gAddress+1 ; and $800-8FF
         ldy   #<gRWTSParams
         lda   #>gRWTSParams
         jsr   $BD00

         ;write replaced block

         lda   #8         ; $800-9FF
         sta   mliparam+3 ; hi byte of data buffer
         dec   mliparam+4 ; lo byte of block number
         jsr   SwapProDOS
         lda   #$81       ; 'write block' command
         ldy   #$03       ; parameter count
         jsr   mli
         jsr   SwapProDOS

         ;restore original disk location

.restore
         dec   gTrack     ; #0
         lda   #$0F
         sta   gSector

.exit
}
